#include "search.hpp"

#include "board.hpp"

#include <boost/pool/pool_alloc.hpp>
#include <boost/shared_ptr.hpp>

#include <limits>
#include <cassert>
#include <stack>
#include <queue>
#include <iostream>

namespace {
vertex::number_t add(vertex::number_t first, vertex::number_t second) {
  if (first < vertex::infty && second < vertex::infty) {
    return first + second;
  } else {
    return vertex::infty;
  }
}

//! Get the board corresponding to a given vertex. That means traversing the whole tree from the given vertex up to root,
//! then back down, transforming the initial board.
board board_from_vertex(vertex_ptr vertex, board const& initial_board) {
  std::stack<step> stack;

  boost::optional<step> s = vertex->leading_step;
  while (s) {
    stack.push(*s);

    vertex = vertex->get_parent();
    if (vertex) {
      s = vertex->leading_step;
    }
  }

  // Now, go from initial_board to the final one by going down the stack and applying the steps.
  board result = initial_board;
  while (!stack.empty()) {
    apply(stack.top(), result);
    stack.pop();
  }

  return result;
}

}

vertex::number_t const vertex::infty = std::numeric_limits<vertex::number_t>::max() - 1;
vertex::number_t const vertex::max_num = std::numeric_limits<vertex::number_t>::max();

vertex::vertex()
  : proof_number(0)
  , disproof_number(0)
  , hash(0)
  , steps_remaining(0)
  , parent(0)
  , children_size(0)
{ }

vertex::children_iterator vertex::children_begin() {
  return children.get();
}

vertex::children_iterator vertex::children_end() {
  return children.get() + children_size;
}

vertex::const_children_iterator vertex::children_begin() const {
  return children.get();
}

vertex::const_children_iterator vertex::children_end() const {
  return children.get() + children_size;
}

vertex::reverse_children_iterator vertex::children_rbegin() {
  return reverse_children_iterator(children_end());
}

vertex::reverse_children_iterator vertex::children_rend() {
  return reverse_children_iterator(children_begin());
}

vertex::const_reverse_children_iterator vertex::children_rbegin() const {
  return const_reverse_children_iterator(children_end());
}

vertex::const_reverse_children_iterator vertex::children_rend() const {
  return const_reverse_children_iterator(children_begin());
}

vertex* vertex::get_parent() {
  return parent;
}

void vertex::alloc_children(std::size_t count) {
  assert(!children.get());
  children_size = count;
  children.reset(new vertex[count]);
}

void vertex::dealloc_children() {
  children_size = 0;
  children.reset();
}

void vertex::set_parent(vertex* new_parent) {
  assert(parent == 0);
  parent = new_parent;
}

vertex* find_min(vertex::children_iterator begin, vertex::children_iterator end, vertex::number_t vertex::*number) {
  vertex::number_t min = vertex::max_num;
  vertex* min_child = 0;

  for (; begin != end; ++begin) {
    if (begin->*number < min) {
      min = begin->*number;
      min_child = begin;
    }
  }

  return min_child;
}

vertex::e_type opposite_type(vertex::e_type to_what) {
  switch (to_what) {
  case vertex::type_and:  return vertex::type_or;
  case vertex::type_or:   return vertex::type_and;
  default: assert(!"It's gone pear-shaped!");
  }

  return vertex::type_and;  // Fix a compiler warning.
}

vertex* basic_pns_traversal::successor(vertex* v) const {
  vertex::number_t vertex::* number = v->type == vertex::type_or ? &vertex::proof_number : &vertex::disproof_number;
  return find_min(v->children_begin(), v->children_end(), number);
}

