\documentclass{article}
\usepackage[czech]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{url}
\usepackage{fullpage}
\usepackage{algorithmic}
\usepackage{algorithm}
\usepackage{amsmath}
\usepackage{float}

\begin{document}
\begin{flushright}
  Ondřej Majerech
\end{flushright}
\begin{center}
  \Huge Dokumentace ročníkového projektu
\end{center}

\section{Účel}
Program je primárně experimentální implementací algoritmu \emph{Proof-Number Search} v adaptaci pro hru \emph{Arimaa}.
Má ukázat vhodnost zmíněného algoritmu při řešení koncových částí hry. Program má spíše teoretický význam, protože jeho
hlavním výstupem je částečně prohledaný stavový prostor hry -- tento výstup je ale možné použít jako vstup jiného
programu.

\section{Podporované systémy}
Program je určený pro systémy Microsoft Windows a FreeBSD. K běhu je na obou systémech potřeba mít instalovaný
Python verze 2.7 (pro Windows ke stažení na \url{http://python.org/download/}). 

Pro Windows je připraven zip soubor obsahující vše potřebné pro spuštění programu -- ten lze získat na adrese
\url{https://github.com/Oxyd/APNS} kliknutím na tlačítko \emph{Download} a následně stažením souboru
\texttt{apns-windows-32bit.zip} pro 32bitové Windows či \texttt{apns-windows-64bit.zip} pro 64bitový systém.

 Na platformě FreeBSD je potřeba prvně program přeložit -- o tom více v části \ref{sec:compiling}.

\section{Běh programu}
\label{sec:running}
Program je možné spustit buďto s grafickým rozhraním či v dávkovém režimu. Grafické rozhraní zobrazuje spočtený strom a
v každém jeho vrcholu zobrazuje příslušnou situaci na hrací ploše. 

\subsection{Grafické rozhraní}
Grafické rozhraní lze ve Windows spustit poklepáním na ikonu souboru \texttt{gui.pyw}. Ve Windows i FreeBSD lze grafické
rozhraní spustit příkazem \texttt{python gui.pyw} z příkazové řádky v adresáři s programem.

Grafické rozhraní v levé části zobrazuje výsledný strom, pravá část ukazuje příslušnou herní pozici po vybrání některého
z vrcholů stromu. Tlačítka v horní části rozhraní umožňují výběr nové počáteční pozice, zahájení výpočtu, načtení
předchozího výpočtu z disku, uložení výpočtu na disk a uložení vybrané pozice na disk.

Po skončení výpočtu je možné procházet výsledný strom, který je zobrazený v levé části okna programu. Sloupec
\emph{Step} určuje krok vedoucí do příslušného vrcholu; \emph{Type} říká, jakého typu je příslušný vrchol -- buď
\emph{OR} pro vrchol, ze kterého táhne původní hráč, či \emph{AND}, což je stav, ze kterého táhne protivník.

Vybráním některého vrcholu se v pravé části zobrazí pozice odpovídající stavu hry po provedení kroku v sloupci
\emph{Step}.

Nulová hodnota \emph{PN} znamená, že příslušný uzel stromu je \emph{dokázaný} -- tedy pokud se hra dostane do stavu
představovaného tímto vrcholem, pak začínající hráč může zaručeně vyhrát. Podobně, je-li hodnota \emph{DN} nulová,
znamená to, že dostane-li se hra do tohoto stavu, nemůže původní hráč vyhrát, protože tato pozice zaručuje vítězství
protivníkovi. Takový vrchol se nazývá \emph{vyvrácený}.

\subsubsection{Příklad 1: Prozkoumání stavového prostoru vedoucího z jednoduché pozice}
\paragraph{Spuštění výpočtu}
V souboru \texttt{puzzle1-one-move.txt} v adresáři \texttt{example-positions} je připravena jednoduchá startovní pozice.
Řekněme, že chceme prozkoumat všechny možnosti, abychom zjistili, zda a jak může zlatý hráč zvítězit.

Klepnutím na \emph{New Initial Position} se zobrazí dialogové okno umožňující zadání nové pozice či její načtení z
disku. Jelikož zmíněná pozice je již připravena v souboru, stačí z adreséře \texttt{example-positions} vybrat soubor
\texttt{puzzle1-{}one-{}move.txt}. Načtená pozice se pak zobrazí na obrazovce a je možné ji dále upravovat. Stiskem
\texttt{Ok} se pozice načte jako kořenová pozice stromu.

Nyní je možné spustit výpočet. Po stisku \emph{Run Search} se zobrazí dialog umožňující nastavit dobu trvání výpočtu
a velikost použité transpoziční tabulky. Pro zmíněnou pozici, která je velmi jednoduchá, jsou výchozí parametry naprosto
postačující. Stiskem \emph{Run} se zahájí výpočet.

\paragraph{Výsledky}
V tomto příkladě se velmi rychle povede dokázat kořen stromu -- hodnota \emph{PN} kořene je nulová. To znamená, že se
programu povedlo dokázat, že zlatý hráč má zaručené vítězství. To je zaručené krokem \emph{Dc7n} -- tedy přesunem psa z
C7 směrem vzhůru -- protože stav vzniklý tímto krokem je opět dokázaný. Po kliknutí na \emph{Dc7n} se pravá část okna
programu aktualizuje a zobrazí pozici vzniklou provedením tohoto kroku.

Z této pozice je možné pokračovat krokem \emph{Dc8s rd8w} -- odtažení stříbrného zajíce psem doleva. Opět je to dokázaná
pozice. Pod ní konečně je pozice \emph{Rd7n} -- posun zlatého zajíce do cílové řady, neboli vítězství zlatého hráče.

Celkově je tedy vidět, že ze startovní pozice může zlatý hráč zvítězit volbou kroků \emph{Dc7n Dc8s rd8w Rd7n}.

První tři kroky v této posloupnosti jsou typu \emph{OR} -- jsou to kroky, ze kterých dál táhne zlatý hráč. Poslední krok
je typu \emph{AND}, protože by z něj táhl hráč stříbrný (pokud by neprohrál). Většina pozic se ve stromě vyskytuje
dvakrát -- pokaždé s jiným typem. Pozice typu \emph{OR} představuje situaci, kdy zlatý hráč udělá krok a pokračuje ve
svém tahu; \emph{AND} se stejným krokem znamená, že po provedení kroku zlatý hráč svůj tah skončí a nechá hrát soupeře.

\subsubsection{Příklad 2: Načítání a ukládání stavového prostoru}
\label{sec:gui-example-2}
Pro tento příklad zvolme jako počáteční pozici soubor \texttt{gold-to-play-and-win-in-2-moves.txt}. Opět jako v příkladu
1 stačí zvolit \emph{New Initial Position}, \emph{Load} a zvolit příslušný soubor v adresáři s příklady. Tato pozice je
však na výpočet daleko složitější než ta z prvního příkladu.

Volbou \emph{Run Search} opět spustíme výpočet -- díky složitosti této pozice se dá očekávat, že na běžném PC program
nevydá definitivní výsledek ani po přednastaveném šedesátisekundovém limitu.

Je-li tedy již strom (čátečně) spočítán, můžeme zvolit \emph{Save Search}, vybrat jméno souboru, kam se strom uloží --
například \texttt{search-1.txt} -- a potvrdit tlačítkem \emph{Ok}. Pro demonstrační účely je nyní možné program ukončit
a poté opět spustit. Pak stiskem \emph{Load Search} znovu vybrat soubor \texttt{search-1.txt}. Program by nyní měl
zobrazovat stejný strom jako před ukončením.

Dále je možné třeba znovu stisknout \emph{Run Search} a pokračovat ve výpočtu.

\subsection{Dávkové rozhraní}
Dávkové rozhraní umožňuje provádění výpočtu z příkazové řádky či dávkového souboru bez nutnosti použití grafického
rozhraní. Všechny parametry výpočtu musí být zadány jako parametry na příkazové řádce. Výpočet je kdykoliv možné ukončit
stiskem kláves \texttt{Ctrl-C}.

\subsubsection{Spouštění a parametry příkazové řádky}
Z příkazové řádky je možné dávkové rozhraní programu spustit příkazem \texttt{python batch.py \textit{parametry}}.
Nejsou-li zadány žádné parametry, vypíše program stručný soupis všech parametrů a skončí. Stručnou nápovědu je možné
vyvolat parametrem \texttt{--help}, tedy příkazem \texttt{python batch.py --help}.

Důležité parametry jsou:\begin{description}
  \item[\texttt{-p} \textit{pozice}] Udává cestu k souboru s počáteční pozicí. Jeho funkce je analogická funkci
  \emph{New Initial Position} z grafického rozhraní.
  \item[\texttt{-d} \textit{výstup}] Udává cestu k souboru, do kterého se uloží spočtený strom. Tato funkce je analogem
  tlačítka \emph{Save Search} z grafického rozhraní.
  \item[\texttt{-s} \textit{strom}] Udává cestu k souboru, ve kterém je částečně spočtený vyhledávací strom, ve kterém
  se má pokračovat ve výpočtu. Tedy stejná funkce, kterou v grafickém rozhraní zastává tlačítko \emph{Load Search}.
  \item[\texttt{-t} \textit{sekundy}] Umožňuje nastavit časový limit (v sekundách) pro vyhledávání (výchozí hodnota je
  60 sekund)
\end{description}

Parametr \texttt{-d} je povinný. Dále uživatel musí zadat buď parametr \texttt{-p} nebo parametr \texttt{-s}.

\subsubsection{Příklad 1: Prozkoumávání stavového stromu z dané pozice}
Opět jako v prvním příkladu u grafického rozhraní budeme chtít spočítat příslušný strom, máme-li v souboru uloženou
počáteční pozici. Pro tento příklad zvolme třeba pozici \texttt{puzzle3-one-move.txt}, pro kterou program dokáže vydat
kladný výsledek (zlatý hráč vítězí) na mém PC po přibližně 7 sekundách. Řekněme, že výsledek chceme uložit do souboru
\texttt{search-2.txt}.

Příslušný příkaz včetně parametrů tedy bude vypadat takto:
\begin{center}\verb+python batch.py -p example-positions/puzzle3-one-move.txt -d search-2.txt+\end{center}

Pokud je výpočet přerušen ještě před jeho dokončením, program stejně vypíše částečně spočtený strom do specifikovaného
souboru.

Výstup, tedy soubor \texttt{search-2.txt}, je pak možné otevřít v grafickém rozhraní a procházet jak bylo uvedeno v
předchozích částech.

\subsubsection{Příklad 2: Pokračování v předešlém výpočtu}
Řekněme, že chceme pokračovat ve výpočtu, který jsme začali v části \ref{sec:gui-example-2} -- tedy máme soubor
\texttt{search-1.txt}, který je částečným výsledekm prohledávání z pozice \texttt{gold-to-play-and-win-in-2-moves.txt}.
Výsledek chceme uložit do souboru \texttt{search-3.txt}.

Nyní tedy místo parametru \texttt{-p} uvedeme parametr \texttt{-s} specifikující předešlé vyhledávání. Tedy -- za
předpokladu, že soubor \texttt{search-1.txt} je uložen v kořenovém adresáři programu -- bude celý příkaz vypadat
následovně:
\begin{center}\verb+python batch.py -s search-1.txt -d search-3.txt+\end{center}

\subsection{Transpoziční tabulka a její vliv na výpočet}
Během výpočtu si program pamatuje některé navštívené pozice v \emph{transpoziční tabulce}. To umožňuje zrychlení
výpočtu, neboť někdy je možné ke stejné pozici dojít vícero způsoby a transpoziční tabulka pak zajišťuje, že není třeba
stejnou pozici vyhodnocovat vícekrát.

Do transpoziční tabulky se však nemohou vejít všechny záznamy. Počet záznamů, které se do tabulky vejdou, je přímo určen
její velikostí v paměti. Velikost transpoziční tabulky lze nastavit v grafickém rozhraní volbou \emph{Transposition
Table Size}, v řádkovém rozhraní pak parametrem \texttt{-r \textit{velikost v MB}}.

\subsection{Zobrazované informace během výpočtu}
Během prohledávání stavového prostoru program vypisuje některé informace. Mezi ně patří \begin{description}
\item[\emph{Search Memory Usage}] Přibližné množství paměti používané programem. Tato hodnota nezahrnuje všech\-nu
použitou paměť, a tedy zobrazená hodnota bude vždy nižší než hodnota skutečná. Přesto však může sloužit jako dobrý
ukazatel paměťové náročnosti programu.
\item[\emph{Unique Positions Total}] Celkový počet pozic.
\item[\emph{New Positions per Second}] Navýšení hodnoty \emph{Unique Positions Total} za poslední sekundu.
\item[\emph{Transposition Table Size}] Paměť použitá transpoziční tabulkou. Tato hodnota je též započítána do
\emph{Search Memory Usage}.
\item[\emph{Transposition Table Hits}] Počet úspěšných vyhledání v transpoziční tabulce.
\item[\emph{Transposition Table Misses}] Počet neúspěšných pokusů o vyhledání v transpoziční tabulce.
\end{description}

\section{Překlad programu}
\label{sec:compiling}

\subsection{Prerekvizity}
Pro překlad je třeba mít kompletní zdrojový kód programu. Ten lze obstarat přes systém git příkazem
\begin{center}\verb+git clone git://github.com/Oxyd/APNS.git+\end{center} či stažením zdrojového archivu ve formátu
\texttt{.zip} či \texttt{.tar.gz} z \url{https://github.com/Oxyd/APNS}.

Dále je třeba mít v systému instalovány následující knihovny a nástroje\begin{description}
\item[SCons] Používaný nástroj pro sestavení programu. Instalátor pro Windows je možné získat na
\url{http://scons.org/}. Na systému FreeBSD stačí instalovat port \texttt{devel/scons}.
\item[Boost] Kolekce knihoven, z nichž některé program používá. Je třeba mít verzi aspoň 1.44. Stáhnout lze z
\url{http://boost.org/}, kde jsou i informace pro sestavení kolekce. Na FreeBSD je možné instalovat port
\texttt{devel/boost-all}.
\item[Google Test] Není nezbytně nutný pro překlad; používá se pouze pro jednotkové testy. Na FreeBSD existuje v portu
\texttt{devel/googletest}. Pro Windows se stačí obrátit na stránky projektu na
\url{http://code.google.com/p/googletest/}.
\end{description}

Je třeba dále mít k dispozici překladač jazyka C++. Sestavovací skript automaticky použije překladač z \emph{Microsoft
Visual Studia} na systému Windows -- je třeba mít verzi 10. (Měla by stačit i verze 9 a 8, ale to není otestované.) Na
FreeBSD se pro překlad používá překladač \emph{GCC} -- je ovšem třeba mít překladač verze aspoň 4.5. Ten lze instalovat
z portu \texttt{lang/gcc45}.

Překlad na Windows by měl být možný i pomocí kolekce \emph{MinGW} -- sestavovací skript to však nepodporuje, a bylo by
tedy nutné ho před tím upravit. Dále očekávám, že program půjde beze změn či jenom s minimálními změnami přeložit a
spustit i na dalších systémech, zejména různých distribucích systému \emph{GNU/Linux} -- to jsem ovšem netestoval, a
výsledek není zaručen.

\subsection{Konfigurace pro překlad}
Než je možné program přeložit, je třeba určit umístění používaných knihoven na systému, kde má překlad probíhat. To se
provádí úpravou souboru \texttt{build\_config.py}. V souboru jsou komentáře vysvětlující jak nastavit příslušné hodnoty.

\subsection{Překlad}
Překlad lze spustit příkazem \verb+scons+ v kořenovém adresáři se zdrojovým kódem programu. Pokud překlad proběhne
úspěšně, není třeba žádných dalších kroků; program je spustitelný tak, jak bylo popsáno v části \ref{sec:running}.

Pro účely vývoje programu může být vhodné přeložit program tak, aby obsahoval ladicí informace. V tom případě je třeba
překlad spustit příkazem \verb+scons debug=1+. Navíc je možné specifikovat cíl \texttt{tests}, který přeloží a provede
jednotkové testy -- tedy použít příkaz \verb+scons tests+. Jednotlivé jednotkové testy je možné vyvolat cílem
\emph{jméno\_testu}, kde \emph{jméno\_testu} odpovídá jménu souboru v adresáři \texttt{apns\_module/tests} bez koncovky
\texttt{.cpp}. Například tedy pro spuštění jednotkových testů ze souboru \texttt{apns\_module/tests/board\_test.cpp} se
dá použít příkaz \verb+scons board_test+.

Při překladu na systému Windows je též možné specifikovat parametr \texttt{bits=32} nebo \texttt{bits=64}, který určuje,
zda má výsledný program být přeložen pro 32bitovou nebo 64bitovou verzi systému. Kromě toho existuje cíl
\texttt{distrib}, který vytvoří \texttt{zip} soubor s binární distribucí programu.

\section{Vstupní a výstupní data}
\subsection{Pozice}
Vstupní pozice je textový soubor ve formátu popsaném na adrese \url{http://arimaa.com/arimaa/learn/notation.html} v
části \emph{Notation for Recording Arimaa Positions}. Program ale ignoruje číslo tahu a předešlé kroky.

\subsection{Strom}
Stavový strom je ukládán v textovém formátu. Struktura souboru je \begin{itemize}
  \item Na první řádce je počáteční pozice v kompaktním formátu: Seznam figurek na hrací ploše, které jsou oddělené
  mezerami. Jedna figurka je popsána trojznakovým řetězcem, kde první znak určuje řádek ('1' až '8'), druhý značí
  sloupec ('a' až 'h') a třetí znak typ figurky podle oficiálního značení: 'E' značí slona, 'M' velblouda, 'H' koně, 'D'
  psa, 'C' kočku a 'R' zajíce. Typ je značen velkým písmenem, pokud je to figurka zlatého hráče -- figurky stříbrného
  hráče jsou značeny písmeny malými. Například: \begin{center}\verb+5cC 6bE 6cd 6dR 6ee 7cr+\end{center}
  \item Na druhé řádce je \begin{itemize}
    \item Hráč, který je první na tahu jako řetězec buď \texttt{gold} nebo \texttt{silver}.
    \item Počet vrcholů stromu v desítkové soustavě
    \item Obě hodnoty jsou odděleny mezerou
  \end{itemize}
  Například tedy: \begin{center}\verb+gold 100617+\end{center}
  \item Následuje seznam vrcholů stromu. Jeden vrchol je na jedné řádce. Každý vrchol je popsán
  následovně: \begin{center}\texttt{\textit{tah} : \textit{typ} \textit{kroky} \textit{PN}
  \textit{DN} \textit{děti}}\end{center}
  Kde jednotlivé položky jsou:\begin{description}
	  \item[\textit{tah}] Textový pozic tahu vedoucího do této pozice. Používá se oficiální notace pro zápis tahů hry
	  Arimaa. Kořen má místo tahu řetězec \texttt{root}.
	  \item[\textit{typ}] Řetězec \texttt{or} nebo řetězec \texttt{and}. Udává typ vrcholu.
	  \item[\textit{kroky}] Číslo v dekadickém zápisu udávající počet kroků, které ještě může hráč učinit v rámci svého
	  tahu.
	  \item[\textit{PN}] Hodnota \emph{proof number} pro tento vrchol v dekadickém zápisu nebo řetězec ,,\textit{infty}``
	  značící nekonečno.
	  \item[\textit{DN}] Hodnota \emph{disproof number} pro tento vrchol v dekadickém zápisu nebo řetězec ,,\textit{infty}``
	  značící nekonečno.
	  \item[\textit{děti}] Počet potomků tohoto vrcholu v dekadickém zápisu.
  \end{description}
  \item Vrcholy jsou ve stromu uloženy tak, že první je kořen a po každém vrcholu následují jeho potomci. Strom je tedy
  v souboru uložen v pořadí pre-order průchodu do hloubky.
\end{itemize}

\section{Vyhledávací algoritmus}
Program funguje postupným prohledáváním všech možných pozic vzniklých ze zadané počáteční pozice. Pozice jsou uloženy ve
vyhledávacím stromu, kde každý vrchol představuje jednu možnou pozici a jeho potomci jsou vrcholy vzniklé provedením
nějakého platného kroku. Celý tento strom představuje \emph{stavový prostor} hry.

Algoritmus \emph{Proof-Number Search} je \emph{best-first} algoritmus na prohledávání stavového prostoru. Pracuje
postupným rozšiřováním stavového prostoru dokud nedojde k výsledku. Přitom v každé iteraci vždy najde jeden list stromu
a ten \emph{expanduje} -- vygeneruje všechny možné platné kroky z listu a každý jako nový potomek listu připojí ke
stromu.

Jeden vrchol stromu se nazývá \emph{dokázaný}, pokud má původní hráč zaručené vítězství, dostane-li se hra do tohoto
vrcholu. Pokud tento vrchol zaručuje vítězství protivníka, pak je vrchol \emph{vyvrácený}. Cílem algoritmu je dokázat či
vyvrátit kořenový vrchol.

Kvůli velikosti celého stavového prostoru hry je vhodné snažit se prozkoumávat nejdříve ty části stavového prostoru, u
kterých je nejvyšší šance, že v nich algoritmus nalezne řešení celého problému -- tedy že buď najde způsob, jakým může
počáteční hráč zvítězit nebo prokáže, že tento hráč nikdy zvítězit nemůže. K tomuto účelu má každý vrchol přiřazena dvě
čísla: \emph{PN} (\emph{proof number}) a \emph{DN} (\emph{disproof number}). Číslo \emph{PN} udává přibližný počet
vrcholů, které je potřeba dokázat na dokázání tohoto vrcholu; \emph{DN} zase udává přibližný počet vrcholů potřebných na
vyvrácení tohoto vrcholu.

\subsection{Proof-number a disproof-number}
Každý vrchol má dále přiřazen typ -- ten je buď \emph{AND} nebo \emph{OR}. Typ \emph{OR} znamená, že z tohoto vrcholu
táhne původní hráč. Typ \emph{AND} zase, že hraje protivník. Kořen je vždy typu \emph{OR}.

Pro dokázání vrcholu typu \emph{OR} stačí dokázat jednoho potomka -- původní hráč vybírá svůj tah a může si tedy vybrat
ten nejlepší. Naopak pro vyvrácení takového vrcholu je nutné vyvrátit úplně všechny potomky -- neboli dokázat, že
původní hráč vždy prohraje, ať zvolí jakýkoliv tah.

U vrcholu typu \emph{AND} je situace opačná. Dokázat takový vrchol znamená, že ať soupeř zvolí jakýkoliv tah, původní
hráč vyhrává. Je tedy nutné dokázat všechny potomky. Pro jeho vyvrácení stačí vyvrátit jediného potomka.

Pro vrchol $v$ typu \emph{OR} jsou tedy čísla $v.PN$ a $v.DN$ určena následovně:
\begin{align*}
	v.PN &:= \min_{u \text{ je potomek $v$}} u.PN \\
	v.DN &:= \sum_{u \text{ je potomek $v$}} u.DN
\end{align*}

Pro vrchol typu \emph{AND} se tyto hodnoty počítají analogicky.

\subsection{Procházení stromu}
Při sestupu stromem od kořene k listu se program snaží najít takový list, na jehož dokázání či vyvrácení bude třeba co
nejméně práce. Vybírání listu probíhá následovně:

\begin{figure}[H]
{\bf procedure} $\text{findLeaf}(v)$
\begin{algorithmic}
	\IF{$\text{leaf}(v)$}
		\STATE {\bf return} v
	\ELSIF{$\text{type}(v) = OR$}
		\STATE $u \gets \min_{PN} \text{children}(v)$
		\STATE {\bf return} $\text{findLeaf}(u)$
	\ELSE
		\STATE $u \gets \min_{DN} \text{children}(v)$
		\STATE {\bf return} $\text{findLeaf}(u)$
	\ENDIF
\end{algorithmic}
\end{figure}

\subsection{Nové listy}
Hodnoty \emph{PN} a \emph{DN} pro nové listy se v této verzi vždy volí rovny jedné. V příštích verzích by bylo vhodné
zavést lepší heuristiku pro určování těchto iniciálních hodnot pro listy.

\subsection{Transpoziční tabulka}
Při prohledávání stavového prostoru se může stát, že program dojde jinou cestou do stavu, který již prozkoumal. Je
výhodné pamatovat si již prozkoumané vrcholy v nějaké struktuře. K tomu slouží transpoziční tabulka -- je to asociativní
pole indexované \emph{hashem vrcholu}. \emph{Hash vrcholu} je nějaké 64-bitové číslo takové, že dva vrcholy odpovídající
stejnému rozestavení figurek a stejnému hráči na tahu mají vždy stejný hash.

Všech možných hašů je $2^{64}$ -- víc, než se vejde do paměti. Proto je velikost transpoziční tabulky nastavitelná
uživatelem. Je-li velikost tabulky $T$ záznamů, pak se do ní neindexuje přímo hashem $H$ ale hodnotou $H \bmod T$. Tím
můžou vznikat kolize.

Při rozvíjení listu se pak program podívá do transpoziční tabulky, jestli tam není už pro tuto pozici uložen nějaký
záznam, a pokud ano, pak použije hodnoty \emph{PN}, \emph{DN} z uloženého záznamu.

\subsection{Rozvíjení listu}
Při rozvíjení listu program vygeneruje všechny možné kroky z dané pozice -- obou hráčů, pokud mohou oba z toho stavu
hrát. Hra Arimaa má však dvě pravidla, která znamenají, že ne každá úplně každý možný krok je platný:
\begin{enumerate}
  \item Po skončení celého tahu jednoho hráče musí být rozestavění figurek na hrací ploše jiné než na začátku tahu. Tedy
  hráč nesmí udělat ,,prázdný`` tah.
  \item Pokud po skončení celého tahu hráče vznikne potřetí v celé historii jedné hry stejná pozice, ze které má táhnout
  stejný hráč, pak hráč, který právě skončil tah prohrává. Tzv. pravidlo \emph{third-time repetition}.
\end{enumerate}

Tato dvě pravidla mimo jiné zajišťují konečnost každé hry. Pro vyhledávací algoritmus je konečnost hry podstatná,
protože jinak by mohl ve smyčce rozvíjet stále stejné pozice, čímž by neobjevoval žádné nové stavy, ale akorát zbytečně
spotřebovával čas a paměť.

Pro zohlednění tohoto pravidla si algoritmus při sestupu z kořene k listu navíc vytváří \emph{historii} -- seznam dvojic
$(\text{pozice}, \text{hráč})$ pro každý první krok každého tahu. Před připojením listu představující ukončení tahu
aktuálního hráče se nejprve zkontroluje, zda tím nevznikne nějaká pozice, která už je v historii. Pokud se zjistí
porušení některého ze dvou výše uvedených pravidel, tak se tato pozice připojí jako dokázaná či vyvrácená v závislosti
na tom, který hráč se dopustil porušení pravidla.

Rozvíjení listu pak vypadá následovně:
\begin{figure}[H]
{\bf procedure} $\text{expand}(\text{leaf}, \text{history})$
\begin{algorithmic}
\FORALL{$s \gets \text{possibleSteps}(\text{leaf})$}
	\IF{$\text{type}(s) = \text{type}(\text{leaf})$}
		\STATE $\text{attach}(\text{leaf}, \text{Vertex}(s, PN=1, DN=1))$
	\ELSE
		\STATE $pos \gets \text{position}(\text{leaf}, s)$
		\STATE $pl \gets \text{opponent}(\text{leaf})$
		\STATE $rep \gets \left|\left\{ (a, b) \in \text{history} \;:\; a = pos, b = pl \right\}\right|$
		\IF{$rep \ge 3 \lor (pos, pl) = \text{last}(\text{history})$}
			\STATE $\text{attach}(\text{leaf}, \text{Vertex}(s, \text{lose}))$
		\ELSE
			\STATE $\text{attach}(\text{leaf}, \text{Vertex}(s, PN=1, DN=1))$
		\ENDIF
	\ENDIF
\ENDFOR
\end{algorithmic}
\end{figure}

\section{Implementace}
\subsection{Struktura programu}
Program sestává ze dvou částí: Nativního modulu, který implementuje algoritmus samotný a pomocné datové typy a algoritmy
pro reprezentaci hry; a uživatelského rozhraní, které je implementované v jazyku Python.

Algoritmus je v nativním modulu kvůli běhové rychlosti nativního kódu a kvůli tomu, že umožňuje detailnější správu
paměti. Naproti tomu uživatelské rozhraní není příliš výpočetně náročné, tedy není třeba mít ho v nativním kódu. Jazyk
Python navíc obsahuje spoustu předpřipravených knihoven, které velmi usnadňují vývoj grafického (i dávkového)
uživatelského rozhraní.

Implementace celého programu v jazyku C++ by vedlo k přílišnému zesložitění kódu pro interakci s uživatelem. To by nebyl
takový problém, pokud by program žádné grafické rozhraní neměl -- připadá mi ale, že vizualizace stromu a jednotlivých
pozic umožňuje uživateli vytvořit si lepší představu o funkci algoritmu.

Rovněž by bylo možné implementovat celý projekt jako několik programů: Samotný výpočetní program, který by neměl žádné
(nebo jen minimální) uživatelské rozhraní a pak další programy, které by jeho výstup nějak zpracovávaly a vizualizovaly.
To by znamenalo, že program nebude během výpočtu platit za nezbytnou existenci interpreteru jazyka Python v paměti jak
je tomu teď. Na druhou stranu by však nemohl program poskytovat uživateli průběné informace během výpočtu -- leda by
současně běžel druhý program s uživatelským rozhraním a oba programy by spolu nějakým způsobem komunikovaly -- to by
ovšem představovalo stejný overhead jako nyní a navíc overhead na komunikaci mezi procesy. Dále by se některé datové
struktury musely duplikovat ve více programech -- počítací program by měl vlastní reprezentaci stromu v paměti, ke které
by však uživatelské rozhraní nemělo přístup. Program s uživatelským rozhraním by pak musel mít vlastní reprezentaci
stromu.

Výpočetní část programu je tedy implementována jako nativní modul jazyka Python. Vnitřní datové struktury -- jako strom
samotný či hrací plocha a reprezentace kroků -- jsou přímo přístupné kódu v Pythonu a nemusí se duplikovat. To také
znamená, že je teoreticky možné implementovat část algoritmu v Pythonu -- například různé heuristické funkce. Tím sice
jistě vznikne netriviální overhead, ale umožní to snadno testovat experimentální vylepšení algoritmu -- pokud se
vylepšení prokáže jako rozumné, nebude problém ho přepsat do nativního modulu.

Rovněž je možné spustit interpret Pythonu v interaktivním režimu, v něm načíst výpočetní modul a interaktivně spouštět
části algoritmu či procházet vzniklé datové struktury. To se mi prokázalo jako poměrně praktický nástroj při ladění
programu.

\subsection{Reprezentace dat}
\subsubsection{Hrací plocha}
Hrací plocha je reprezentována jednoduše jako 64-prvkové pole, kde každý prvek obsahuje, zda na té pozici je figurka,
jakého je typu a jaké barvy. Dohromady tedy aspoň 3 B na jednu možnou pozici. Tato reprezentace, ač se zdá neefektivní
(teoreticky by stačil 1 B na jednu pozici, či dokonce jen 4 bity), se mi prakticky projevila jako nejlepší, neboť
nevyžaduje žádnou další interpretaci dat -- každý bajt je možné bez další konverze přímo interpretovat jako správnou
informaci. Implementace se navíc snaží nevytvářet zbytečné kopie hrací plochy.

\subsubsection{Kroky}
Krok -- změna hrací plochy z jednoho platného stavu do druhého platného stavu -- je reprezentován jako řetězec ve
stejném formátu v jakém jsou kroky popisovány v oficiálních zápisech hry. Program vytváří poměrně mnoho kroků a
prakticky se mi ukázalo vhodné zvolit tuto poměrně kompaktní reprezentaci oproti přímějším variantám.

Krok samotný navíc nevyžaduje, aby k němu byla v paměti uložena odpovídající hrací plocha. V každém vrcholu stromu je
proto uložen jenom krok, kterým vznikne patřičná hrací plocha z rodičovského vrcholu, namísto aby tam byla uložena celá
hrací plocha.

\subsubsection{Vrchol stromu}
Kromě nezbytných informací o kroku, hodnotách \emph{PN} a \emph{DN} je v každém vrcholu třeba udržovat informaci o jeho
rodiči a potomcích.

Pro reprezentaci potomků jsem zvolil pole následníků. Tato reprezentace má několik výhod:\begin{itemize}
  \item Nízký overhead: V každém vrcholu stačí mít uložený pouze ukazatel na začátek pole následníků a velikost tohoto
  pole. Žádné další informace nejsou potřeba.
  \item Následníci jsou v paměti uloženi pořadě ihned za sebou. Taková reprezentace je cache-friendly při sekvenčním
  procházení všech následníků, což je velmi častá operace. (Jiný druh průchodu ostatně ani není třeba.)
\end{itemize}

Na druhou stranu taková reprezentace neumožňuje snadno měnit seznam potomků bez zavedení další režie. Algoritmu však
stačí vytvářet listy, které jsou bez potomků, a pak listy rozvíjet -- to lze udělat tak, aby se všichni potomci přidali
najednou. Po rozvinutí vrcholu se jeho seznam potomků již nemění.

Tato reprezentace mi tedy připadá jako nejvhodnější, ač je poměrně neflexibilní.

\section{Závěrem}
Můj původní záměr byl reprezentovat stavový prostor hry jako orientovaný acyklický graf (DAG) -- místo používání pouze
hodnot \emph{PN}, \emph{DN} z transpoziční tabulky by se k rozvíjenému listu připojil přímo již existující vrchol. To by
znamenalo zefektivnění výpočtu, protože většina duplicitních pozic by nemusela být ve stromu vícekrát.

Zajištění acykličnosti grafu se však prokázalo jako netriviální ale velmi podstatné. Cyklus v grafu neznamená jenom
možnost zacyklení celého algoritmu při výběru nejlepšího listu, ale též to nereprezentuje správně stavový prostor hry --
pravidla explicitně znemožňují opakování stále těch samých pozic dokola (pravidlo \emph{third-time repetition}).

Nakonec jsem od tohoto záměru upustil a rozhodl se pro jednodušší, i když méně efektivní reprezentaci obyčejným
stromem. Transpoziční tabulka pouze dodává ,,lepší`` počáteční hodnoty \emph{PN}, \emph{DN}. I zde vzniká problém s
\emph{graph history interaction} -- vyzvednuté hodnoty mohou být nesprávné, to však neovlivňuje správnost algoritmu --
pouze jeho efektivitu. Program však nemůže použít vyzvednuté hodnoty, pokud značí dokázaný či vyvrácený vrchol (neboť
hodnoty nemusí být správné).
\end{document}
% vim:textwidth=120
